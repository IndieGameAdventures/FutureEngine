!<arch>
//                                              174       `
heapallocator.cpp/
poolallocator.cpp/
mallocallocator.cpp/
stackallocator.cpp/
memorytracker.cpp/
managedobject.cpp/
criticalsection.cpp/
posix_thread.cpp/
workerthread.cpp/
log.cpp/        1371409224  1006  513   100000  1263      `
#include <future/core/debug/debug.h>
#include <stdarg.h>
#include <wchar.h>


// default assert to be used unless another function is specified
static void FutureLogFunctionDefault(u8 severness, string file, u32 line, string message, ...)
{
	va_list val;
	va_start(val, message);

	wchar_t buffer[2048];
	int count = vswprintf(buffer, FUTURE_ARRAY_LENGTH(buffer), message, val);
	if(count > FUTURE_ARRAY_LENGTH(buffer) || count < 0)
	{
		FUTURE_DEBUG_HALT();
	}

	va_end(val);

	wchar_t * se;
	switch(severness)
	{
	case FutureMessageSeverness::MESSAGE_VERBOSE:
		se = L"VERBOSE";
		break;
	case FutureMessageSeverness::MESSAGE_INFO:
		se = L"INFO";
		break;
	case FutureMessageSeverness::MESSAGE_DEBUG:
		se = L"DEBUG";
		break;
	case FutureMessageSeverness::MESSAGE_WARNING:
		se = L"WARNING";
		break;
	case FutureMessageSeverness::MESSAGE_ERROR:
		se = L"ERROR";
		break;
	}

	file = wcsrchr(file, '\\' );
	file = (string)((u32)file + sizeof(wchar_t));
	wprintf_s(L"%ls: [%ls:%d] %ls\n", se, file, line, buffer);
}


FutureLogFunction futureLogFunction = FutureLogFunctionDefault;

void FutureSetLogFunction(FutureLogFunction logFunction)
{
	FUTURE_ASSERT(logFunction);
	futureLogFunction = logFunction;
}

assert.cpp/     1371348832  1006  513   100000  1550      `
#include <future/core/debug/debug.h>
#include <stdarg.h>
#include <wchar.h>

// default assert to be used unless another function is specified
static void FutureAssertDefault(string file, u32 line, string message, ...)
{
	va_list val;
	va_start(val, message);

	wchar_t buffer[2048];
	int count = vswprintf_s(buffer, FUTURE_ARRAY_LENGTH(buffer), message, val);
	if(count > FUTURE_ARRAY_LENGTH(buffer) || count < 0)
	{
		FUTURE_DEBUG_HALT();
	}

	va_end(val);

	futureLogFunction(FutureMessageSeverness::MESSAGE_ERROR, file, line, buffer);
	FUTURE_DEBUG_HALT();
}

static void FutureAssertCritDefault(string file, u32 line, s32 errorCode, string message, ...)
{
	va_list val;
	va_start(val, message);

	wchar_t buffer[2048];
	int count = vswprintf(buffer, FUTURE_ARRAY_LENGTH(buffer), message, val);
	if(count > FUTURE_ARRAY_LENGTH(buffer) || count < 0)
	{
		FUTURE_DEBUG_HALT();
	}

	va_end(val);

	futureLogFunction(FutureMessageSeverness::MESSAGE_ERROR, file, line, L"Critical Error #%i! %ls\n", errorCode, buffer);
	FUTURE_DEBUG_HALT();
}


FutureAssertFunction futureAssertFunction = FutureAssertDefault;
FutureAssertCritFunction futureAssertCritFunction = FutureAssertCritDefault;

void FutureSetAssertFunction(FutureAssertFunction assertFunction)
{
	FUTURE_ASSERT(assertFunction);
	futureAssertFunction = assertFunction;
}

void FutureSetAssertCritFunction(FutureAssertCritFunction assertCritFunction)
{
	FUTURE_ASSERT(assertCritFunction);
	futureAssertCritFunction = assertCritFunction;
}debug.cpp/      1371334825  1006  513   100000  2         `

/0              1371589026  1006  513   100000  6385      `
/*!
*	Copyright 2013 by Lucas Stufflebeam mailto:info@indiegameadventures.com
*
*	Thank you for taking a look at my code. If you like it, please click
*	the donation button at the bottom of the sidebar on my blog. Thanks!
*
*	Licensed under the Apache License, Version 2.0 (the "License");
*	you may not use this file except in compliance with the License.
*	You may obtain a copy of the License at
*
*		http://www.apache.org/licenses/LICENSE-2.0
*
*	Unless required by applicable law or agreed to in writing, software
*	distributed under the License is distributed on an "AS IS" BASIS,
*	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*	See the License for the specific language governing permissions and
*	limitations under the License.
*
*/

/*
*	Implementation of FutureHeapAllocator
*/

#include <future/core/debug/debug.h>
#include <future/core/memory/allocators/heapallocator.h>
#include <future/core/memory/memory.h>
#include <future/core/memory/tracker/memorytracker.h>
#include <new>

/*******************************************************************/
// Heap Allocator

FutureHeapAllocator::FutureHeapAllocator(u8 align, u32 heapSize, bool usingHeaders)
	: m_align(align),
	  m_heapSize(heapSize),
	  m_heaps(NULL),
	  m_usingHeaders(usingHeaders)
{
	FUTURE_ASSERT(m_heapSize > 0);
	
	// round to nearest multiple of align
	if(align > 0)
	{
		if(!m_usingHeaders)
		{
			m_heapSize += align;
		}
		u32 r = m_heapSize % m_align;
		if(r != 0)
		{
			m_heapSize = m_heapSize + m_align - r;
		}
	}

	m_poolAllocator = new FuturePoolAllocator(4, sizeof(Block), 1024, false);
	AddHeap();
}

void * FutureHeapAllocator::Alloc(u32 bytes)
{
	if(!m_usingHeaders)
	{
		bytes += 4;
	}
	FUTURE_ASSERT_CRIT(bytes <= m_heapSize, 9875);
	// keep the heap aligned	
	u32 r = bytes % m_align;
	if(r != 0)
	{
		bytes = bytes + m_align - r;
	}

	Block * block = NULL;
	Block * blockPrev = NULL;
	Heap * heap = NULL;
	u32 dif = m_heapSize;

	m_criticalSection.Lock();

	// Loop through all current blocks and find the smallest block with enough room
	// for our object
	for(heap = m_heaps; heap; heap = heap->m_next)
	{
		blockPrev = NULL;
		Block * last = NULL;
		for(Block * checkBlock = heap->m_freeBlocks; checkBlock; checkBlock = checkBlock->m_next)
		{
			if(checkBlock->m_size >= bytes)
			{
				u32 d = checkBlock->m_size - bytes;
				if(d < dif)
				{
					block = checkBlock;
					blockPrev = last;
					dif = d;
					if(dif == 0)
					{
						break;
					}
				}
			}
			last = block;
		}
		if(block)
		{
			break;
		}
	}

	if(!heap || !block)
	{
		FUTURE_LOG_INFO(L"Heap is full, expanding");
		AddHeap();
		heap = m_heaps;
		block = heap->m_freeBlocks;
		blockPrev = NULL;
	}

	FUTURE_ASSERT(heap && block && block->m_size >= bytes);

	void * data = block->m_data;
	
	if(block->m_size == bytes)
	{
		if(blockPrev)
		{
			blockPrev->m_next = block->m_next;
		}
		if(block == heap->m_freeBlocks)
		{
			heap->m_freeBlocks = heap->m_freeBlocks->m_next;
		}
		m_poolAllocator->Free(block);
	}
	else
	{
		block->m_size -= bytes;
		block->m_data = (void*)((u32)block->m_data + bytes);
	}

	m_criticalSection.Unlock();

	
	if(m_usingHeaders)
	{
		FutureAllocHeader * header = reinterpret_cast<FutureAllocHeader *>(data);
		header->m_allocatorData = bytes;
		return data;
	}
	else
	{
		u32 * header = (u32*)data;
		*header = bytes;
		return (void*)(header + 1);
	}
}

void FutureHeapAllocator::Free(void * p)
{
	m_criticalSection.Lock();
	Heap * heap = m_heaps;
	for( ;heap; heap = heap->m_next)
	{
		if((u32)p >= (u32)heap->m_data && (u32)p < (u32)heap->m_data + m_heapSize)
		{
			break;
		}
	}
	FUTURE_ASSERT_MSG(heap, L"Attempting to free a block that does not belong to this heap");
	
	u32 size = 0;
	if(m_usingHeaders)
	{
		FutureAllocHeader * header = reinterpret_cast<FutureAllocHeader *>(p);
		size = header->m_allocatorData;
	}
	else
	{
		u32 * header = ((u32*)p) - 1;
		size = *header;
		p = (void*)header;
	}
	FUTURE_ASSERT(size > 0 && size <= m_heapSize);

	bool found = false;
	if(heap->m_freeBlocks != NULL)
	{
		// check to see if this block is next to another block
		for(Block * checkBlock = heap->m_freeBlocks; checkBlock && !found; checkBlock = checkBlock->m_next)
		{
			// checkBlock is before this one
			if((u32)checkBlock->m_data + checkBlock->m_size == (u32)p)
			{
				checkBlock->m_size += size;
				found = true;
			}
			// checkBlock is directly after this block
			else if((u32)p + size == (u32)checkBlock->m_data)
			{
				checkBlock->m_size += size;
				checkBlock->m_data = p;
				found = true;
			}
		}
	}

	if(!found)
	{
		// we couldn't add this to another block so make a new one
		Block * block = (Block*)m_poolAllocator->Alloc(sizeof(Block));
		block->m_data = p;
		block->m_size = size;
		block->m_next = heap->m_freeBlocks;
		heap->m_freeBlocks = block;
	}
	
	m_criticalSection.Unlock();
}

u8 FutureHeapAllocator::Priority()
{
	return 200;
}

bool FutureHeapAllocator::ShouldAllocate(FutureMemoryParam memParam)
{
	return (memParam.m_bytes + FutureMemory::HeaderSize() < m_heapSize / 4);
}

void FutureHeapAllocator::Release()
{
	for(Heap * heap = m_heaps; heap; )
	{
		for(Block * block = heap->m_freeBlocks; block;)
		{
			Block * nextBlock = block->m_next;
			m_poolAllocator->Free(block);
			block = nextBlock;
		}
		if(heap->m_data)
		{
			if(!m_usingHeaders && m_align >= 4)
			{
				heap->m_data = (void*)((u32)heap->m_data - (m_align - 4));
			}
			_aligned_free(heap->m_data);
		}
		Heap * next = heap->m_next;
		m_poolAllocator->Free(heap);
		heap = next;
	}
	m_heaps = NULL;
	m_poolAllocator->Release();
	delete m_poolAllocator;
	m_poolAllocator = NULL;
}

void FutureHeapAllocator::AddHeap()
{
	Heap * heap = (Heap*)m_poolAllocator->Alloc(sizeof(Heap));
	heap->m_data = _aligned_malloc(m_heapSize, m_align);
	heap->m_next = m_heaps;
	m_heaps = heap;

	if(!m_usingHeaders && m_align >= 4)
	{
		heap->m_data = (void*)((u32)heap->m_data + (m_align - 4));
	}

	Block * block = (Block*)m_poolAllocator->Alloc(sizeof(Block));
	block->m_data = heap->m_data;
	block->m_next = NULL;
	block->m_size = m_heapSize;
	heap->m_freeBlocks = block;
}
/19             1371749582  1006  513   100000  4795      `
/*!
*	Copyright 2013 by Lucas Stufflebeam mailto:info@indiegameadventures.com
*
*	Thank you for taking a look at my code. If you like it, please click
*	the donation button at the bottom of the sidebar on my blog. Thanks!
*
*	Licensed under the Apache License, Version 2.0 (the "License");
*	you may not use this file except in compliance with the License.
*	You may obtain a copy of the License at
*
*		http://www.apache.org/licenses/LICENSE-2.0
*
*	Unless required by applicable law or agreed to in writing, software
*	distributed under the License is distributed on an "AS IS" BASIS,
*	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*	See the License for the specific language governing permissions and
*	limitations under the License.
*
*/

/*
*	Implementation of FuturePoolAllocator
*/

#include <future/core/debug/debug.h>
#include <future/core/memory/allocators/poolallocator.h>
#include <future/core/memory/memory.h>
#include <future/core/memory/tracker/memorytracker.h>
#include <new>

#ifndef FUTURE_MAX_POOL_GROUP_SIZE
#	define FUTURE_MAX_POOL_GROUP_SIZE	1024
#endif

/*******************************************************************/
// Pool Allocator

FuturePoolAllocator::FuturePoolAllocator(u8 align, u8 poolSize, u32 numPools, bool accountForHeaders)
	: m_align(align),
	  m_poolSize(align),
	  m_freeList(NULL),
	  m_pools(0),
	  m_groupList(NULL),
	  m_usingHeaders(accountForHeaders),
	  m_groupSize(numPools)
{
	FUTURE_ASSERT(poolSize > 0 && numPools > 0);
	
	if(align > 1)
	{
		while(m_poolSize < poolSize + (accountForHeaders ? FutureMemory::HeaderSize() : 4))
		{
			m_poolSize += align;
		}
	}
	else
	{
		m_poolSize = poolSize + (accountForHeaders ? FutureMemory::HeaderSize() : 4);
	}

	if(m_groupSize > FUTURE_MAX_POOL_GROUP_SIZE)
	{
		m_groupSize = FUTURE_MAX_POOL_GROUP_SIZE;
	}

	while(m_pools < numPools)
	{
		AddPoolGroup();
	}
}

void * FuturePoolAllocator::Alloc(u32 bytes)
{
	FUTURE_ASSERT_CRIT(bytes <= m_poolSize, 9865);


	if(m_freeList == NULL)
	{
		//FUTURE_LOG_INFO(L"Pool Allocator is full, expanding");
		AddPoolGroup();
	}
	FUTURE_ASSERT_CRIT(m_freeList != NULL, 9864);

	Lock();

	Pool * pool = m_freeList;
	m_freeList = m_freeList->m_next;
	
	Unlock();

	return pool->m_data;
}

void FuturePoolAllocator::Free(void * p)
{
	Pool * pool;
	if(m_usingHeaders)
	{
		FutureAllocHeader * header = reinterpret_cast<FutureAllocHeader *>(p);
		pool = (Pool*)header->m_allocatorData;
	}
	else
	{
		u32 * header = ((u32*)p) - 1;
		pool = (Pool*)(*header);
	}

	FUTURE_ASSERT(pool->m_data == p);

	Lock();

	if(m_freeList == NULL)
	{
		m_freeList = pool;
	}
	else
	{
		pool->m_next = m_freeList;
		m_freeList = pool;
	}

	Unlock();
}

// set to 100 + the pool size, this way smaller pool sizes are checked first
u8 FuturePoolAllocator::Priority()
{
	return 100 + (m_poolSize / 8);
}

// Make sure we have room to spare, if we do and the requested bytes is the right size, return true
bool FuturePoolAllocator::ShouldAllocate(FutureMemoryParam memParam)
{
	if(memParam.m_bytes + (m_usingHeaders ? FutureMemory::HeaderSize() : 4) <= m_poolSize)
	{
		return true;
	}
	return false;
}

void FuturePoolAllocator::Release()
{
	Lock();
	for(Pool * group = m_groupList; group; )
	{
		if(group->m_data)
		{
			if(((Pool*)(group->m_data))->m_data)
			{
				if(m_usingHeaders)
				{
					_aligned_free(((Pool*)(group->m_data))->m_data);
				}
				else
				{
					void * data = ((Pool*)(group->m_data))->m_data;
					data = (void*)(((u32*)data) - 1);
					_aligned_free(data);
				}
			}
			_aligned_free(group->m_data);
		}
		Pool * next = group->m_next;
		delete group;
		group = next;
	}
	m_groupList = NULL;
	m_freeList = NULL;
	m_pools = 0;
	Unlock();
}

void FuturePoolAllocator::AddPoolGroup()
{
	Pool * pools = (Pool*)_aligned_malloc((sizeof(Pool) * m_groupSize), m_align);
	void * data = _aligned_malloc(m_poolSize * m_groupSize, m_align);

	Pool * group = new Pool();
	group->m_data = pools;
	group->m_next = m_groupList;
	if(m_groupList == NULL)
	{
		m_groupList = group;
	}

	for(u16 i = 0; i < m_groupSize && pools != NULL; ++i)
	{
		pools->m_next = (i < m_groupSize - 1 ? pools + 1 : m_freeList);
		if(m_usingHeaders)
		{
			FutureAllocHeader * header = reinterpret_cast<FutureAllocHeader *>(data);
			header->m_allocatorData = (u32)pools;
			pools->m_data = data;
		}
		else
		{
			u32 * header = (u32*)data;
			*header = (u32)pools;
			pools->m_data = (void*)(header + 1);
		}
		++pools;
		data = (void*)((u32)data + m_poolSize);
	}

	Lock();

	m_freeList = (Pool*)(group->m_data);
	m_pools += m_groupSize;

	Unlock();
}
/38             1371440631  1006  513   100000  1678      `
/*!
*	Copyright 2013 by Lucas Stufflebeam mailto:info@indiegameadventures.com
*
*	Thank you for taking a look at my code. If you like it, please click
*	the donation button at the bottom of the sidebar on my blog. Thanks!
*
*	Licensed under the Apache License, Version 2.0 (the "License");
*	you may not use this file except in compliance with the License.
*	You may obtain a copy of the License at
*
*		http://www.apache.org/licenses/LICENSE-2.0
*
*	Unless required by applicable law or agreed to in writing, software
*	distributed under the License is distributed on an "AS IS" BASIS,
*	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*	See the License for the specific language governing permissions and
*	limitations under the License.
*
*/

/*
*	Implementation of FutureMallocAllocator
*/

#include <future/core/memory/allocators/mallocallocator.h>
#include <future/core/memory/memory.h>
#include <new>

/*******************************************************************/
// Default Malloc allocator, aligned allocations

void * FutureMallocAllocator::Alloc(u32 bytes)
{
	return _aligned_malloc(bytes, m_align);
}

void FutureMallocAllocator::Free(void * p)
{
	_aligned_free(p);
}

// return the highest priority possible, this should be our last resort allocator
u8 FutureMallocAllocator::Priority()
{
	return 255;
}

// As this allocator is our default allocator, always return true
bool FutureMallocAllocator::ShouldAllocate(FutureMemoryParam memParam)
{
	return true;
}

void FutureMallocAllocator::SetAlign(u8 align)
{
	m_align = align;
}

void FutureMallocAllocator::Release()
{
}/59             1371589020  1006  513   100000  5051      `
/*!
*	Copyright 2013 by Lucas Stufflebeam mailto:info@indiegameadventures.com
*
*	Thank you for taking a look at my code. If you like it, please click
*	the donation button at the bottom of the sidebar on my blog. Thanks!
*
*	Licensed under the Apache License, Version 2.0 (the "License");
*	you may not use this file except in compliance with the License.
*	You may obtain a copy of the License at
*
*		http://www.apache.org/licenses/LICENSE-2.0
*
*	Unless required by applicable law or agreed to in writing, software
*	distributed under the License is distributed on an "AS IS" BASIS,
*	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*	See the License for the specific language governing permissions and
*	limitations under the License.
*
*/

/*
*	Implementation of FutureStackAllocator
*/

#include <future/core/debug/debug.h>
#include <future/core/memory/allocators/stackallocator.h>
#include <future/core/memory/memory.h>
#include <future/core/memory/tracker/memorytracker.h>
#include <new>

/*******************************************************************/
// Stack Allocator

FutureStackAllocator::FutureStackAllocator(u8 align, u32 stackSize, bool usingHeaders)
	: m_align(align),
	  m_stackSize(stackSize),
	  m_stacks(NULL),
	  m_usingHeaders(usingHeaders)
{
	FUTURE_ASSERT(m_stackSize > 0);
	
	// round to nearest multiple of align
	if(align > 0)
	{
		if(!m_usingHeaders)
		{
			m_stackSize += align;
		}
		u32 r = m_stackSize % m_align;
		if(r != 0)
		{
			m_stackSize = m_stackSize + m_align - r;
		}
	}

	m_poolAllocator = new FuturePoolAllocator(4, sizeof(Block), 1024 * 256, false);
	AddStack();
}

void * FutureStackAllocator::Alloc(u32 bytes)
{
	if(!m_usingHeaders)
	{
		bytes += 4;
	}
	FUTURE_ASSERT_CRIT(bytes <= m_stackSize, 9875);
	// keep the heap aligned	
	u32 r = bytes % m_align;
	if(r != 0)
	{
		bytes = bytes + m_align - r;
	}

	m_criticalSection.Lock();

	Stack * stack = m_stacks;

	if((m_stackSize - ((u32)stack->m_position - (u32)stack->m_data)) < bytes)
	{
		FUTURE_LOG_INFO(L"Stack is full, expanding");
		AddStack();
		stack = m_stacks;
	}

	FUTURE_ASSERT(stack && (m_stackSize - ((u32)stack->m_position - (u32)stack->m_data)) >= bytes);

	void * data = stack->m_position;
	stack->m_position = (void*)((u32)stack->m_position + bytes);
	Block * block = (Block*)m_poolAllocator->Alloc(sizeof(Block));
	block->m_size = bytes;
	block->m_next = stack->m_blocks;
	stack->m_blocks = block;

	m_criticalSection.Unlock();

	if(m_usingHeaders)
	{
		FutureAllocHeader * header = reinterpret_cast<FutureAllocHeader *>(data);
		header->m_allocatorData = (u32)block;
		return data;
	}
	else
	{
		u32 * header = (u32*)data;
		*header = (u32)block;
		return (void*)(header + 1);
	}
}

void FutureStackAllocator::Free(void * p)
{
	Block * block;
	if(m_usingHeaders)
	{
		FutureAllocHeader * header = reinterpret_cast<FutureAllocHeader *>(p);
		block = (Block*)header->m_allocatorData;
	}
	else
	{
		u32 * header = ((u32*)p) - 1;
		block = (Block*)(*header);
		p = (void*)header;
	}

	FUTURE_ASSERT(block);

	if(m_stacks->m_blocks == NULL)
	{
		FUTURE_ASSERT(m_stacks->m_data == m_stacks->m_position);
		m_criticalSection.Lock();
		Stack * stack = m_stacks;
		if(stack->m_data)
		{
			if(!m_usingHeaders && m_align >= 4)
			{
				stack->m_data = (void*)((u32)stack->m_data - (m_align - 4));
			}
			_aligned_free(stack->m_data);
		}
		m_stacks = stack->m_next;
		delete stack;
		m_criticalSection.Unlock();
	}

	FUTURE_ASSERT_MSG(m_stacks->m_blocks == block, L"Freeing stack in the wrong order.");

	m_criticalSection.Lock();
	Stack * stack = m_stacks;

	stack->m_position = (void *)((u32)stack->m_position - block->m_size);
	stack->m_blocks = block->m_next;
	m_poolAllocator->Free(block);
	
	m_criticalSection.Unlock();
}

u8 FutureStackAllocator::Priority()
{
	return 255;
}

bool FutureStackAllocator::ShouldAllocate(FutureMemoryParam memParam)
{
	return false;
}

void FutureStackAllocator::Release()
{
	for(Stack * stack = m_stacks; stack; )
	{
		for(Block * block = stack->m_blocks; block;)
		{
			Block * nextBlock = block->m_next;
			m_poolAllocator->Free(block);
			block = nextBlock;
		}
		if(stack->m_data)
		{
			if(!m_usingHeaders && m_align >= 4)
			{
				stack->m_data = (void*)((u32)stack->m_data - (m_align - 4));
			}
			_aligned_free(stack->m_data);
		}
		Stack * next = stack->m_next;
		delete stack;
		stack = next;
	}
	m_stacks = NULL;
	m_poolAllocator->Release();
	delete m_poolAllocator;
	m_poolAllocator = NULL;
}

void FutureStackAllocator::AddStack()
{
	Stack * stack = new Stack();
	stack->m_data = _aligned_malloc(m_stackSize + sizeof(Stack), m_align);
	stack->m_next = m_stacks;
	m_stacks = stack;
	stack->m_blocks = NULL;

	if(!m_usingHeaders && m_align >= 4)
	{
		stack->m_data = (void*)((u32)stack->m_data + (m_align - 4));
	}
	stack->m_position = stack->m_data;
}
/79             1371516806  1006  513   100000  8856      `
/*!
*	Copyright 2013 by Lucas Stufflebeam mailto:info@indiegameadventures.com
*
*	Thank you for taking a look at my code. If you like it, please click
*	the donation button at the bottom of the sidebar on my blog. Thanks!
*
*	Licensed under the Apache License, Version 2.0 (the "License");
*	you may not use this file except in compliance with the License.
*	You may obtain a copy of the License at
*
*		http://www.apache.org/licenses/LICENSE-2.0
*
*	Unless required by applicable law or agreed to in writing, software
*	distributed under the License is distributed on an "AS IS" BASIS,
*	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*	See the License for the specific language governing permissions and
*	limitations under the License.
*
*/

/*
*	Implementation of MemoryTracker
*/

#include <future/core/debug/debug.h>

#include <future/core/memory/memory.h>

#include <future/core/thread/criticalsection/criticalsection.h>
#include <future/core/memory/allocators/allocator.h>
#include <future/core/memory/memorystatistics.h>
#include <future/core/memory/tracker/memorytracker.h>
#include <future/core/utils/timer/timer.h>
	
FutureMemoryTracker * FutureMemoryTracker::instance;

void FutureMemoryTracker::CreateInstance()
{
	FUTURE_ASSERT(FutureMemoryTracker::instance == NULL);
	FutureMemoryTracker::instance = new FutureMemoryTracker();
};

void FutureMemoryTracker::DestroyInstance()
{
	FUTURE_ASSERT(FutureMemoryTracker::instance != NULL);
	delete FutureMemoryTracker::instance;
	FutureMemoryTracker::instance = NULL;
};

FutureMemoryTracker * FutureMemoryTracker::GetInstance()
{
	return FutureMemoryTracker::instance;
}

// Create the memory tracker
FutureMemoryTracker::FutureMemoryTracker( )
	: m_criticalsection(),
	  m_headerRoot(),
	  m_totalAllocations(0),
	  m_totalAllocationTime(0),
	  m_totalBytesAllocated(0)
{
	// set up the header list
	m_headerRoot.m_bytes = 0;
	m_headerRoot.m_line = 0;
	m_headerRoot.m_file = L"Start";
	m_headerRoot.m_next = NULL;
	m_headerRoot.m_previous = NULL;
	SetChecksum(&m_headerRoot);
	m_headerTail = &m_headerRoot;
}

// destroy the tracker
FutureMemoryTracker::~FutureMemoryTracker()
{
	// make sure there are no memory leaks
	if(m_headerRoot.m_next != NULL)
	{
		LogAllocations();
		FUTURE_ASSERT_MSG(false, L"Memory Leak! Memory Tracker destroyed with active allocations");
	}
}

	
/*******************************************************************/
// Memory Tracker tracking functions

void FutureMemoryTracker::Track(FutureMemoryParam memParam, FutureAllocHeader * header, f32 startTime)
{
	// if the allocation failed then we are out of memory!
	FUTURE_ASSERT_CRIT_MSG(header != NULL, 9871, L"Out of memory!");

#if FUTURE_TRACK_MEMORY

	if (header == NULL)
	{
		return;
	}

	// create the header
	header->m_bytes = memParam.m_bytes;
	header->m_type = memParam.m_type;
	header->m_file = wcsrchr(memParam.m_file, '\\' );
	header->m_file = (string)((u32)header->m_file + sizeof(wchar_t));
	header->m_line = memParam.m_line;
	SetChecksum(header);
		
	// Only one thread can change the header list and statistics at a time
	m_criticalsection.Lock();
	// Add the new header to the header list
	header->m_next = NULL;
	m_headerTail->m_next = header;
	header->m_previous = m_headerTail;
	m_headerTail = header;
	/*m_headerRoot.m_next;
	if(m_headerRoot.m_next)
	{
		m_headerRoot.m_next->m_previous = header;
	}
	header->m_previous = &m_headerRoot;
	m_headerRoot.m_next = header;*/
		
	// Update statistics
	m_totalBytesAllocated += header->m_bytes;
	m_totalAllocations += 1;
	m_totalAllocationTime += FutureTimer::TimeSince(startTime);

	// Make sure other threads can access this now
	m_criticalsection.Unlock();

	// make sure everything copied right
	FUTURE_ASSERT(header->m_line == memParam.m_line);
	FUTURE_ASSERT(header->m_bytes == memParam.m_bytes);
	FUTURE_ASSERT(header->m_bytes != 24296);
	VerifyChecksum(header);
#endif
}

void FutureMemoryTracker::Untrack(FutureAllocHeader * header)
{
#if FUTURE_TRACK_MEMORY
	if(header == NULL)
	{
		return;
	}

	// make sure it is not corrupt
	VerifyChecksum(header);

	// Only one thread can change the header list at a time
	m_criticalsection.Lock();

	// Remove the header from the header list
	FutureAllocHeader * next = header->m_next;
	FutureAllocHeader * prev = header->m_previous;

	FUTURE_ASSERT(prev != NULL);
	prev->m_next = next;
	if(next != NULL)
	{
		next->m_previous = prev;
	}
	else
	{
		// this header is the tail
		m_headerTail = prev;
	}

	// Make sure we allow other threads in when we are done
	m_criticalsection.Unlock();
#endif
}

// check all headers to make sure memory is not corrupt
void FutureMemoryTracker::VerifyAllocations()
{
#if FUTURE_TRACK_MEMORY
	for(FutureAllocHeader * header = m_headerRoot.m_next; header != NULL; header = header->m_next)
	{
		VerifyChecksum(header);
	}
#endif
}

// Set the header's check sum, each header has a unique check sum
void FutureMemoryTracker::SetChecksum(FutureAllocHeader * header)
{
#if FUTURE_TRACK_MEMORY
	header->m_checkSum = FUTURE_CHECKSUM ^ reinterpret_cast<u32>(header) ^ header->m_bytes;
#endif
}

// make sure the check sum for this header is correct, assert if is it not.
void FutureMemoryTracker::VerifyChecksum(FutureAllocHeader * header)
{
#if FUTURE_TRACK_MEMORY
	// NOTE: If this assert fires, then memory is corrupt or some else weird is happening.
	FUTURE_ASSERT_CRIT(header->m_checkSum == (FUTURE_CHECKSUM ^ reinterpret_cast<u32>(header) ^ header->m_bytes), 9899);
#endif
}


	
/*******************************************************************/
// Print debug information about the Memory Tracker

FutureMemoryStatistics FutureMemoryTracker::GetStatistics()
{
	FutureMemoryStatistics stats;
	stats.m_currentBytes = 0;
	stats.m_currentAllocations = 0;
	
#if FUTURE_TRACK_MEMORY
	for(FutureAllocHeader * header = m_headerRoot.m_next; header != NULL; header = header->m_next)
	{
		++stats.m_currentAllocations;
		stats.m_currentBytes += header->m_bytes;
	}
#endif

	stats.m_totalBytes = m_totalBytesAllocated;
	stats.m_totalAllocations = m_totalAllocations;
	stats.m_totalTimeForAllocations = m_totalAllocationTime;
	stats.m_averageAllocationSize = m_totalBytesAllocated / m_totalAllocations;
	stats.m_averageTimeForAllocation = m_totalAllocationTime / (f32)m_totalAllocations;

	return stats;
}

void FutureMemoryTracker::LogStatistics()
{
#if FUTURE_TRACK_MEMORY	
	FutureMemoryStatistics stats = GetStatistics();

	FUTURE_LOG_DEBUG(L"Current allocations: %u", stats.m_currentAllocations);
	FUTURE_LOG_DEBUG(L"Current bytes allocated: %u", stats.m_currentBytes);
	FUTURE_LOG_DEBUG(L"Total allocations: %u", m_totalAllocations);
	FUTURE_LOG_DEBUG(L"Total bytes allocated: %u", m_totalBytesAllocated);
	FUTURE_LOG_DEBUG(L"Total time for allocations: %f", stats.m_totalTimeForAllocations);
	FUTURE_LOG_DEBUG(L"Average allocation size: %u", stats.m_averageAllocationSize);
	FUTURE_LOG_DEBUG(L"Average allocation time: %f", stats.m_averageTimeForAllocation);
#else
	__noop; // don't do anything if not tracking
#endif
}

void FutureMemoryTracker::LogAllocations()
{
#if FUTURE_TRACK_MEMORY		
	if (!m_headerRoot.m_next )
	{
		FUTURE_LOG_DEBUG(L"No Current Allocations");
		return;
	}

	FutureMemoryStatistics stats = GetStatistics();
	u32 allocations = 0;
	f32 time = FutureTimer::CurrentTime();
	for(FutureAllocHeader * header = m_headerRoot.m_next; header != NULL; header = header->m_next)
	{
		++allocations;
		FUTURE_LOG_DEBUG(
			L"%u: Type: %ls File: %ls Line: %u Size: %u Percent: %f",
			allocations,
			header->m_type,
			header->m_file,
			header->m_line,
			header->m_bytes,
			((f32)header->m_bytes / (f32)stats.m_currentBytes) * 100.0f);
	}

	FUTURE_LOG_DEBUG(L"Current allocations: %u", stats.m_currentAllocations);
	FUTURE_LOG_DEBUG(L"Current bytes allocated: %u", stats.m_currentBytes);
	FUTURE_LOG_DEBUG(L"Total allocations: %u", m_totalAllocations);
	FUTURE_LOG_DEBUG(L"Total bytes allocated: %u", m_totalBytesAllocated);
	FUTURE_LOG_DEBUG(L"Total time for allocations: %f", stats.m_totalTimeForAllocations);
	FUTURE_LOG_DEBUG(L"Average allocation size: %u", stats.m_averageAllocationSize);
	FUTURE_LOG_DEBUG(L"Average allocation time: %f", stats.m_averageTimeForAllocation);
#else
	__noop; // don't do anything if not tracking
#endif
}

void FutureMemoryTracker::LogAllocation(FutureAllocHeader * header)
{
#if FUTURE_TRACK_MEMORY	
	FUTURE_LOG_DEBUG(
		L"Type: %ls File: %ls Line: %u Size: %u",
		header->m_type,
		header->m_file,
		header->m_line,
		header->m_bytes);
#else
	__noop; // don't do anything if not tracking
#endif
}
memory.cpp/     1371864319  1006  513   100000  9952      `
/*!
*	Copyright 2013 by Lucas Stufflebeam mailto:info@indiegameadventures.com
*
*	Thank you for taking a look at my code. If you like it, please click
*	the donation button at the bottom of the sidebar on my blog. Thanks!
*
*	Licensed under the Apache License, Version 2.0 (the "License");
*	you may not use this file except in compliance with the License.
*	You may obtain a copy of the License at
*
*		http://www.apache.org/licenses/LICENSE-2.0
*
*	Unless required by applicable law or agreed to in writing, software
*	distributed under the License is distributed on an "AS IS" BASIS,
*	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*	See the License for the specific language governing permissions and
*	limitations under the License.
*
*/

/*
*	Implementation of FutureMemory
*/

#include <future/core/debug/debug.h>

#include <future/core/memory/memory.h>

#include <future/core/thread/criticalsection/criticalsection.h>
#include <future/core/memory/allocators/allocator.h>
#include <future/core/memory/allocators/mallocallocator.h>
#include <future/core/memory/allocators/heapallocator.h>
#include <future/core/memory/allocators/poolallocator.h>
#include <future/core/memory/memorystatistics.h>
#include <future/core/memory/tracker/memorytracker.h>
#include <future/core/utils/timer/timer.h>

//#include <stdlib.h>
//#include <assert.h>
//#include <new>
//#include <string>

/*******************************************************************/
// Structure to keep track of memory allocators
struct AllocatorList
{
	IFutureAllocator *	m_allocator;
	AllocatorList *		m_next;
};

	
/*******************************************************************/
// Memory System
class MemorySystem
{
public:
	MemorySystem();
	~MemorySystem();

	void *					Alloc(FutureMemoryParam memParam);
	void					Free(void * p );
	void *					ReAlloc(void * p, FutureMemoryParam memParam);

	u32						BytesForAllocation(FutureMemoryParam memParam);
	void					AddAllocator(IFutureAllocator * allocator);
	IFutureAllocator *		GetAllocator(int i);

	IFutureAllocator *		GetBestAllocator(FutureMemoryParam memParam);
	IFutureAllocator *		GetPreviousAllocator(void * p);
	
	FutureMemoryStatistics	GetStatistics();
	
	void					LogStatistics();
	void					LogAllocations();
	void					LogAllocation(void *);

	FutureCriticalSection	m_criticalsection;
	AllocatorList *			m_allocators;
	u8						m_globalAlign;
};

MemorySystem * memory;

/*******************************************************************/
// FutureMemory implementation

static u32 futureHeaderSize = 0;
void FutureMemory::CreateMemory(u8 globalAlign)
{
	FUTURE_ASSERT(memory == NULL);
	memory = new MemorySystem();
	memory->m_globalAlign = globalAlign;

	// make the header size a multiple of the global alignment for
	// easier and quicker allocations.
	futureHeaderSize = globalAlign;
	if(sizeof(FutureAllocHeader) > globalAlign)
	{
		while(futureHeaderSize < sizeof(FutureAllocHeader))
		{
			futureHeaderSize += globalAlign;
		}
	}
	((FutureMallocAllocator*)(memory->m_allocators->m_allocator))->SetAlign(globalAlign);
	FutureMemoryTracker::CreateInstance();

	memory->AddAllocator(new FuturePoolAllocator(globalAlign, 32, 1024));
	memory->AddAllocator(new FutureHeapAllocator(globalAlign));
}

void FutureMemory::DestroyMemory()
{
	FUTURE_ASSERT(memory != NULL);
	FutureMemoryTracker::DestroyInstance();
	delete memory;
	memory = NULL;
}

void * FutureMemory::Alloc(FutureMemoryParam memParam)
{
	return memory->Alloc(memParam);
}
void FutureMemory::Free(void * p)
{
	memory->Free(p);
}
void * FutureMemory::ReAlloc(void * p, FutureMemoryParam memParam)
{
	return memory->ReAlloc(p, memParam);
}
u32	FutureMemory::BytesForAllocation(FutureMemoryParam memParam)
{
	return memory->BytesForAllocation(memParam);
}
void FutureMemory::AddAllocator(IFutureAllocator * allocator)
{
	memory->AddAllocator(allocator);
}
IFutureAllocator * FutureMemory::GetAllocator(int i)
{
	return memory->GetAllocator(i);
}
FutureMemoryStatistics FutureMemory::GetStatistics()
{
	return memory->GetStatistics();
}
void FutureMemory::LogStatistics()
{
	return memory->LogStatistics();
}
void FutureMemory::LogAllocations()
{
	return memory->LogAllocations();
}
void FutureMemory::LogAllocation(void * p)
{
	return memory->LogAllocation(p);
}
u8 FutureMemory::GetGlobalAlignment()
{
	return memory->m_globalAlign;
}


inline u32 FutureMemory::HeaderSize()
{
	return futureHeaderSize; 
}

inline static void * DataFromHeader(FutureAllocHeader * header)
	{ return (void *)(reinterpret_cast< u32 >(header) + FutureMemory::HeaderSize()); }
inline static FutureAllocHeader * HeaderFromData(void * p)
	{ return reinterpret_cast<FutureAllocHeader *>(reinterpret_cast<u32>(p) - FutureMemory::HeaderSize()); }


/*******************************************************************/
// Memory System functions
void * MemorySystem::Alloc(FutureMemoryParam memParam)
{
	if(memParam.m_bytes <= 0)
	{
		return NULL;
	}
#if FUTURE_TRACK_MEMORY
	f32 time = FutureTimer::CurrentTime();
#endif
	IFutureAllocator * allocator = GetBestAllocator(memParam); // get the best allocator
	void * p = allocator->Alloc(BytesForAllocation(memParam)); // allocate enough bytes for the header
	FutureAllocHeader * header = reinterpret_cast<FutureAllocHeader *>(p);
	header->m_allocator = allocator;
#if FUTURE_TRACK_MEMORY
	FutureMemoryTracker::GetInstance()->Track(memParam, header, time);
#endif
	return DataFromHeader(header);
}

void MemorySystem::Free(void * p)
{
#if FUTURE_TRACK_MEMORY	
	FutureMemoryTracker::GetInstance()->Untrack(HeaderFromData(p));
#endif
	IFutureAllocator * allocator = GetPreviousAllocator(p);
	allocator->Free(HeaderFromData(p));
}

void * MemorySystem::ReAlloc(void * p, FutureMemoryParam memParam)
{
#if FUTURE_TRACK_MEMORY
	f32 time = FutureTimer::CurrentTime();
#endif
	IFutureAllocator * allocator = GetBestAllocator(memParam);
	void * data = allocator->Alloc(BytesForAllocation(memParam));
	FutureAllocHeader * header = reinterpret_cast<FutureAllocHeader *>(data);
	memcpy(DataFromHeader(header), p, memParam.m_bytes);
	header->m_allocator = allocator;
	Free(HeaderFromData(p));
#if FUTURE_TRACK_MEMORY
	FutureMemoryTracker::GetInstance()->Track(memParam, header, time);
#endif
	return DataFromHeader(header);
}

	
/*******************************************************************/
// Memory Tracker private functions

// Loop through all available allocators and return the first allocator
// that returns true for ShouldAllocate
IFutureAllocator * MemorySystem::GetBestAllocator(FutureMemoryParam memParam)
{
	if(!m_allocators)
	{
		return NULL;
	}
	AllocatorList* allocator = m_allocators;
	while(allocator && !allocator->m_allocator->ShouldAllocate(memParam))
	{
		allocator = allocator->m_next;
	}
	// if no allocator was found, then use the first one
	if(allocator == NULL)
	{
		return m_allocators->m_allocator;
	}
	return allocator->m_allocator;
}

// Get the allocator used to allocate this memory
IFutureAllocator * MemorySystem::GetPreviousAllocator(void * p)
{
	FutureAllocHeader * header = (FutureAllocHeader *)HeaderFromData(p);
	return header->m_allocator;
}

void MemorySystem::AddAllocator(IFutureAllocator * allocator)
{
	if(!m_allocators)
	{
		m_allocators = new AllocatorList;
		m_allocators->m_allocator = allocator;
		m_allocators->m_next = NULL;
		return;
	}
	AllocatorList * last = NULL;
	for(AllocatorList* a = m_allocators; a; a = a->m_next)
	{
		// check for duplicates
		if(a->m_allocator == allocator)
		{
			// found it, so leave the function
			return;
		}
			
		// find the first link with a higher priority than the new one
		if(a->m_allocator->Priority() > allocator->Priority())
		{
			break;
		}
		last = a;
	}

	// create the new link in the correct location
	AllocatorList * link = new AllocatorList;
	link->m_allocator = allocator;
	link->m_next = NULL;
	if(last)
	{
		link->m_next = last->m_next;
		last->m_next = link;
	}
	else
	{
		link->m_next = m_allocators;
		m_allocators = link;
	}
}

IFutureAllocator * MemorySystem::GetAllocator(int i)
{		
	int index = 0;
	for(AllocatorList* a = m_allocators; a; a = a->m_next)
	{
		if(index == i)
		{
			return a->m_allocator;
		}
		++i;
	}
	FUTURE_ASSERT_MSG(false, L"Index out of bounds exception looking for index %i", i);
	return NULL;
}
	
// Create the memory tracker
MemorySystem::MemorySystem( )
	: m_criticalsection(),
	  m_allocators(NULL)
{
	// create a default allocator 
	AddAllocator(new FutureMallocAllocator());
}

// destroy the tracker
MemorySystem::~MemorySystem()
{
	// loop through all allocators and release them
	for(AllocatorList* allocator = m_allocators; allocator; )
	{
		AllocatorList* next = allocator->m_next;
		if(allocator->m_allocator)
		{
			allocator->m_allocator->Release();
			delete allocator->m_allocator;
			allocator->m_allocator = NULL;
		}
		delete allocator;
		allocator = next;
	}
}

	
/*******************************************************************/
// Memory Tracker tracking functions

inline u32 MemorySystem::BytesForAllocation(FutureMemoryParam memParam)
{
	if (memParam.m_bytes == 0)
	{
		return 0;
	}
	return FutureMemory::HeaderSize() + memParam.m_bytes;
}

FutureMemoryStatistics MemorySystem::GetStatistics()
{
	return FutureMemoryTracker::GetInstance()->GetStatistics();
}

void MemorySystem::LogStatistics()
{
	FutureMemoryTracker::GetInstance()->LogStatistics();
}

void MemorySystem::LogAllocations()
{
	FutureMemoryTracker::GetInstance()->LogAllocations();
}

void MemorySystem::LogAllocation(void * p)
{
	FutureMemoryTracker::GetInstance()->LogAllocation(HeaderFromData(p));
}/98             1371747033  1006  513   100000  2033      `
/*!
*	Copyright 2013 by Lucas Stufflebeam mailto:info@indiegameadventures.com
*
*	Thank you for taking a look at my code. If you like it, please click
*	the donation button at the bottom of the sidebar on my blog. Thanks!
*
*	Licensed under the Apache License, Version 2.0 (the "License");
*	you may not use this file except in compliance with the License.
*	You may obtain a copy of the License at
*
*		http://www.apache.org/licenses/LICENSE-2.0
*
*	Unless required by applicable law or agreed to in writing, software
*	distributed under the License is distributed on an "AS IS" BASIS,
*	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*	See the License for the specific language governing permissions and
*	limitations under the License.
*
*/

/*	
*	Implementation of FutureManagedObject
*/
#include <future/core/debug/debug.h>
#include <future/core/memory/memory.h>
#include <future/core/object/pointer/proxy.h>
#include <future/core/object/managedobject.h>

FuturePoolAllocator *	FutureProxyBase::ms_poolAllocator = NULL;
u32						FutureProxyBase::ms_proxyCount = 0;

FutureManagedObject::FutureManagedObject() 
: m_proxy(NULL)
{}

FutureManagedObject::FutureManagedObject(const FutureManagedObject& managed) 
: m_proxy(NULL)
{}

FutureManagedObject::~FutureManagedObject() 
{ 
    if(m_proxy) 
	{           
		delete m_proxy; 
        m_proxy = NULL; 
    }
}

FutureManagedObject& FutureManagedObject::operator=(const FutureManagedObject& managed) 
{
	// we don't want to copy anything so this new object has its own proxy
    return *this; 
}

FutureProxyBase * FutureManagedObject::Proxy() const 
{
    return m_proxy;
}

void FutureManagedObject::SetProxy(FutureProxyBase * proxy) 
{
    FUTURE_ASSERT_MSG(!m_proxy || !proxy, L"Object can only have one proxy");
    m_proxy = proxy;
}

void FutureManagedObject::PrintReferences()
{
#if FUTURE_USE_SMART_POINTERS
	FUTURE_ASSERT(m_proxy);
	m_proxy->PrintReferences();
#endif
}


timer.cpp/      1371343506  1006  513   100000  1323      `
/*!
*	Copyright 2013 by Lucas Stufflebeam mailto:info@indiegameadventures.com
*
*	Thank you for taking a look at my code. If you like it, please click
*	the donation button at the bottom of the sidebar on my blog. Thanks!
*
*	Licensed under the Apache License, Version 2.0 (the "License");
*	you may not use this file except in compliance with the License.
*	You may obtain a copy of the License at
*
*		http://www.apache.org/licenses/LICENSE-2.0
*
*	Unless required by applicable law or agreed to in writing, software
*	distributed under the License is distributed on an "AS IS" BASIS,
*	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*	See the License for the specific language governing permissions and
*	limitations under the License.
*
*/

/*
*	Implementation of FutureTimer
*/

#include <future/core/utils/timer/timer.h>

#include <ctime>

/*******************************************************************/

f32	FutureTimer::CurrentTime()
{
	return (f32)clock() / (f32)CLOCKS_PER_SEC;
};

f32	FutureTimer::TimeSince(f32 start)
{
	return CurrentTime() - start;
}; 

f32	FutureTimer::MilliToSeconds(s64 milliSeconds)
{
	return (f32)milliSeconds / 1000.f;
};

s64	FutureTimer::SecondsToMillis(f32 seconds)
{
	return (u64)(seconds * 1000.f);
};
/117            1371660147  1006  513   100000  2534      `
/*!
*	Copyright 2013 by Lucas Stufflebeam mailto:info@indiegameadventures.com
*
*	Thank you for taking a look at my code. If you like it, please click
*	the donation button at the bottom of the sidebar on my blog. Thanks!
*
*	Licensed under the Apache License, Version 2.0 (the "License");
*	you may not use this file except in compliance with the License.
*	You may obtain a copy of the License at
*
*		http://www.apache.org/licenses/LICENSE-2.0
*
*	Unless required by applicable law or agreed to in writing, software
*	distributed under the License is distributed on an "AS IS" BASIS,
*	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*	See the License for the specific language governing permissions and
*	limitations under the License.
*
*/

/*
*	Implementation of Critical Section
*/

#include <future/core/debug/debug.h>
#include <future/core/thread/criticalsection/criticalsection.h>

// we only want to define these functions is we are using multiple threads
#if FUTURE_ENABLE_MULTITHREADED

/*
*	Initialize the critical section or initialize a new pthread mutex
*/
FutureCriticalSection::FutureCriticalSection()
{
#if FUTURE_PLATFORM_WINDOWS
	InitializeCriticalSection(&m_mutex);
#elif defined(FUTURE_USES_PTHREAD)
	pthread_mutexattr_t mta;
	pthread_mutexattr_init(&mta);
	pthread_mutexattr_settype(&mta, PTHREAD_MUTEX_RECURSIVE);
	pthread_mutex_init(&m_mutex, &mta);
	pthread_mutexattr_destroy(&mta);
#endif
}

	
/*
*	Release the critical section or destroy the mutex
*/
FutureCriticalSection::~FutureCriticalSection()
{
#if FUTURE_PLATFORM_WINDOWS
	DeleteCriticalSection(&m_mutex);
#elif defined(FUTURE_USES_PTHREAD)
	pthread_mutex_destroy(&m_Mutex);
#endif
}
	
/*
*	Lock the mutex, blocks until the mutex is available
*/
void FutureCriticalSection::Lock()
{
#if FUTURE_PLATFORM_WINDOWS
	EnterCriticalSection(&m_mutex);
#elif defined(FUTURE_USES_PTHREAD)
	pthread_mutex_lock(&m_Mutex);
#endif
}
	
/*
*	Unlock the mutex so other threads can access this mutex
*/
void FutureCriticalSection::Unlock()
{
#if FUTURE_PLATFORM_WINDOWS
	LeaveCriticalSection(&m_mutex);
#elif defined(FUTURE_USES_PTHREAD)
	pthread_mutex_unlock(&m_Mutex);
#endif
}
	
	
/*
*	Try to lock this mutex, does not block
*/
bool FutureCriticalSection::TryLock()
{
#if FUTURE_PLATFORM_WINDOWS
	return TryEnterCriticalSection(&m_mutex) == 1;
#elif defined(FUTURE_USES_PTHREAD)
	return pthread_mutex_trylock(&m_Mutex) == 0;
#endif
}

#endifjob.cpp/        1371859380  1006  513   100000  4065      `
/*!
*	Copyright 2013 by Lucas Stufflebeam mailto:info@indiegameadventures.com
*
*	Thank you for taking a look at my code. If you like it, please click
*	the donation button at the bottom of the sidebar on my blog. Thanks!
*
*	Licensed under the Apache License, Version 2.0 (the "License");
*	you may not use this file except in compliance with the License.
*	You may obtain a copy of the License at
*
*		http://www.apache.org/licenses/LICENSE-2.0
*
*	Unless required by applicable law or agreed to in writing, software
*	distributed under the License is distributed on an "AS IS" BASIS,
*	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*	See the License for the specific language governing permissions and
*	limitations under the License.
*
*/

/*
*	Implementation of FutureThreadJob
*
*/
#include <future/core/thread/pool/job.h>

// Constructors
FutureThreadJob::FutureThreadJob()
	: m_state(FutureThreadJob::JobState_Created),
	  m_thread(NULL),
	  m_id(-1),
	  m_priority(FutureThreadJob::JobPriority_Normal),
	  m_autoDelete(true),
	  m_next(NULL),
	  m_function(NULL),
	  m_onFinished(NULL),
	  m_data(NULL)
#if FUTURE_PROFILE_THREAD_POOL
	 ,m_timeAdded(0),
	  m_timeStarted(0),
	  m_timeCompleted(0)
#endif
{}

FutureThreadJob::FutureThreadJob(JobFunction function, void * data, FutureThreadJobPriority priority)
	: m_state(FutureThreadJob::JobState_Created),
	  m_thread(NULL),
	  m_id(-1),
	  m_priority(priority),
	  m_autoDelete(true),
	  m_next(NULL),
	  m_function(function),
	  m_onFinished(NULL),
	  m_data(data)
#if FUTURE_PROFILE_THREAD_POOL
	 ,m_timeAdded(0),
	  m_timeStarted(0),
	  m_timeCompleted(0)
#endif
{}

FutureThreadJob::FutureThreadJob(const FutureThreadJob& job)
	: m_state(FutureThreadJob::JobState_Created),
	  m_thread(NULL),
	  m_id(-1),
	  m_priority(job.m_priority),
	  m_autoDelete(job.m_autoDelete),
	  m_next(NULL),
	  m_function(job.m_function),
	  m_onFinished(job.m_onFinished),
	  m_data(job.m_data)
#if FUTURE_PROFILE_THREAD_POOL
	 ,m_timeAdded(0),
	  m_timeStarted(0),
	  m_timeCompleted(0)
#endif
{}
	
FutureThreadJob::~FutureThreadJob()
{}

// Returns the job's state
FutureThreadJob::FutureThreadJobState FutureThreadJob::GetState()
{
	return m_state;
}

// Gets or sets the job's priority. Higher priority jobs are performed first
FutureThreadJob::FutureThreadJobPriority FutureThreadJob::GetPriority()
{
	return m_priority;
}
void FutureThreadJob::SetPriority(FutureThreadJobPriority priority)
{
	FUTURE_ASSERT(	m_state == FutureThreadJob::JobState_Created ||
					m_state != FutureThreadJob::JobState_Finished);

	m_priority = priority;
}

// The data to be sent to the job function
void * FutureThreadJob::GetData()
{
	return m_data;
}
void FutureThreadJob::SetData(void * data)
{
	FUTURE_ASSERT(	m_state == FutureThreadJob::JobState_Created ||
					m_state != FutureThreadJob::JobState_Finished);

	m_data = data;
}

// Set the functions this job should call
void FutureThreadJob::SetJobFunction(JobFunction function)
{
	FUTURE_ASSERT(	m_state == FutureThreadJob::JobState_Created ||
					m_state != FutureThreadJob::JobState_Finished);

	m_function = function;
}
void FutureThreadJob::SetOnFinishedCallback(FinishedCallbackFunction callback)
{
	FUTURE_ASSERT(	m_state == FutureThreadJob::JobState_Created ||
					m_state != FutureThreadJob::JobState_Finished);

	m_onFinished = callback;
}

void  FutureThreadJob::SetAutoDelete(bool autoDelete)
{
	m_autoDelete = autoDelete;
}

// The job's id, only valid after being added to the ThreadPool
u32 FutureThreadJob::GetId()
{
	return m_id;
}

// The thread that is executing this job, only valid during state = executing
IFutureThread * FutureThreadJob::GetThread()
{
	return m_thread;
}

// executes this job
void FutureThreadJob::Execute(IFutureThread * thread)
{
	m_thread = thread;
	if(m_function)
	{
		m_function(m_data);
	}
	if(m_onFinished)
	{
		m_onFinished(m_data);
	}
}

threadpool.cpp/ 1371868288  1006  513   100000  8620      `
/*!
*	Copyright 2013 by Lucas Stufflebeam mailto:info@indiegameadventures.com
*
*	Thank you for taking a look at my code. If you like it, please click
*	the donation button at the bottom of the sidebar on my blog. Thanks!
*
*	Licensed under the Apache License, Version 2.0 (the "License");
*	you may not use this file except in compliance with the License.
*	You may obtain a copy of the License at
*
*		http://www.apache.org/licenses/LICENSE-2.0
*
*	Unless required by applicable law or agreed to in writing, software
*	distributed under the License is distributed on an "AS IS" BASIS,
*	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*	See the License for the specific language governing permissions and
*	limitations under the License.
*
*/

/*
*	ThreadPool keeps a pool of threads available for performing Jobs. Threadpool
*	keeps a list of jobs in a Priority Queue and pulls jobs off the queue whenever
*	a thread becomes available. Jobs with higher priority are executed first.
*
*	When running in a single threaded application, ThreadPool executes each job
*	on the main thread, when WaitForCompletion is called. If a timeout is specified
*	then ThreadPool will execute as many jobs as possible within the allotted time
*	then exit, leaving unfinished jobs in the queue.
*/

#include <future/core/thread/pool/threadpool.h>
#include <future/core/thread/thread/workerthread.h>
#include <future/core/utils/timer/timer.h>

FutureThreadPool * FutureSingleton<FutureThreadPool>::ms_instance;

FutureThreadPool::FutureThreadPool()
	: m_jobs(NULL)
#if FUTURE_ENABLE_MULTITHREADED
	,m_threads(NULL)
#endif
#if FUTURE_PROFILE_THREAD_POOL
	 ,m_totalJobs(0),
	  m_threadTime(0.f),
	  m_jobTime(0.f)
#endif
{}

FutureThreadPool::~FutureThreadPool()
{
	ClearJobQueue();
#if FUTURE_ENABLE_MULTITHREADED
	for(FutureWorkerThread * thread = m_threads; thread;)
	{
		FutureWorkerThread * next = thread->m_next;
		thread->Release();
		delete thread;
		thread = next;
	}
#endif
}

// Returns the id of the newly added job
u32	FutureThreadPool::AddJob(FutureThreadJob * job)
{
	if(job->m_state != FutureThreadJob::JobState_Created &&
		job->m_state != FutureThreadJob::JobState_Finished)
	{
		return -1;
	}
	
#if FUTURE_ENABLE_MULTITHREADED
	if(!m_threads)
	{
		SetNumThreads(1);
	}
#endif

	Lock();
	job->Lock();
#if FUTURE_PROFILE_THREAD_POOL
	f32 startTime = FutureTimer::CurrentTime();
	job->m_timeAdded = startTime;
#endif
	job->m_state = FutureThreadJob::JobState_ToBeAdded;
	job->m_id = m_totalJobs;
	job->Unlock();
	++m_totalJobs;

	if(m_jobs == NULL)
	{
		m_jobs = job;
		job->Lock();
		job->m_next = NULL;
		job->m_state = FutureThreadJob::JobState_InQueue;
		job->Unlock();
#if FUTURE_PROFILE_THREAD_POOL
		f32 time = FutureTimer::TimeSince(startTime);
		m_threadTime += time;
#endif
		Unlock();
		return job->m_id;
	}
	FutureThreadJob * last = NULL;
	bool added = false;
	for(FutureThreadJob * j = m_jobs; j; j = j->m_next)
	{
		if(j->GetPriority() < job->GetPriority())
		{
			added = true;
			job->Lock();
			job->m_next = j;
			if(last)
			{
				last->m_next = job;
			}
			else
			{
				m_jobs = job;
			}
			job->m_state = FutureThreadJob::JobState_InQueue;
			job->Unlock();
			break;
		}
		last = j;
	}
	if(!added)
	{
		job->Lock();
		if(last)
		{
			last->m_next = job;
			job->m_next = NULL;
		}
		else
		{
			job->m_next = m_jobs;
			m_jobs = job;
		}
		job->m_state = FutureThreadJob::JobState_InQueue;
		job->Unlock();
	}
#if FUTURE_PROFILE_THREAD_POOL
	f32 time = FutureTimer::TimeSince(startTime);
	m_threadTime += time;
#endif
	Unlock();
	return job->m_id;
}

u32	FutureThreadPool::AddJobAtPriority(FutureThreadJob * job, FutureThreadJob::FutureThreadJobPriority priority)
{
	job->SetPriority(priority);
	return AddJob(job);
}

// Removes all jobs from the queue, jobs currently executing will not be stopped
void FutureThreadPool::ClearJobQueue()
{
	Lock();
	for(FutureThreadJob * j = m_jobs; j;)
	{
		FutureThreadJob * next = j->m_next;
		delete j;
		j = next;
	}
	m_jobs = NULL;
	Unlock();
}

// Gets the job with the provided id
FutureThreadJob * FutureThreadPool::GetJob(u32 id)
{
	Lock();
	for(FutureThreadJob * j = m_jobs; j; j = j->m_next)
	{
		if(j->m_id == id)
		{
			Unlock();
			return j;
		}
	}
	Unlock();
	return NULL;
}
// returns the number of jobs in the queue
u32	FutureThreadPool::ActiveJobs()
{
	Lock();
	u32 count = 0;
	for(FutureThreadJob * j = m_jobs; j; j = j->m_next)
	{
		++count;
	}
	Unlock();
	return count;
}

// Checks if there are any active jobs
bool FutureThreadPool::IsProcessing()
{
	Lock();
	if(m_jobs)
	{
		Unlock();
		return true;
	}
#if FUTURE_ENABLE_MULTITHREADED
	for(FutureWorkerThread * thread = m_threads; thread; thread = thread->m_next)
	{
		if(!thread->m_idle)
		{
			Unlock();
			return true;
		}
	}
#endif
	Unlock();
	return false;
}

// Waits until the job queue is empty and all jobs are finished before returning
// In a single threaded environment, this must be called before any jobs are executed
void FutureThreadPool::WaitForCompletion(f32 secondsTimeOut)
{
	f32 startTime = FutureTimer::CurrentTime();
	while(IsProcessing() && (secondsTimeOut <= 0 || FutureTimer::TimeSince(startTime) < secondsTimeOut))
	{
		FutureThreadJob * job = GetNextJob();
		if(job)
		{
			job->Execute(NULL);
			JobFinished(job);
		}
		else
		{
			Sleep(5);
		}
	}

#if FUTURE_PROFILE_THREAD_POOL
	f32 time = FutureTimer::TimeSince(startTime);
	Lock();
	m_threadTime += time;
	Unlock();
#endif
}

void FutureThreadPool::WaitForCompletion(u32 millisTimeOut)
{
	WaitForCompletion((f32)millisTimeOut * 1000.f);
}

// functions for getting and setting the number of active threads
u32	FutureThreadPool::GetNumThreads()
{
#if FUTURE_ENABLE_MULTITHREADED
	Lock();
	u32 count = 0;
	for(FutureWorkerThread * thread = m_threads; thread; thread = thread->m_next)
	{
		++count;
	}
	Unlock();
	return count;
#else
	return 0;
#endif
}
void FutureThreadPool::SetNumThreads(u32 threads)
{
#if FUTURE_ENABLE_MULTITHREADED
#if FUTURE_PROFILE_THREAD_POOL
	f32 startTime = FutureTimer::CurrentTime();
#endif
	u32 count = GetNumThreads();
	while(count < threads)
	{
		FutureWorkerThread * thread = new FutureWorkerThread();
		FutureResult result = thread->Start(NULL);
		if(result == FR_OK)
		{
			Lock();
			thread->m_next = m_threads;
			m_threads = thread;
			++count;
			Unlock();
		}
		else
		{
			return;
		}
	}
	while(count > threads)
	{
		Lock();
		FutureWorkerThread * thread = m_threads;
		m_threads = m_threads->m_next;
		--count;
		Unlock();
		thread->Release();
		delete thread;
	}
#if FUTURE_PROFILE_THREAD_POOL
	f32 time = FutureTimer::TimeSince(startTime);
	Lock();
	m_threadTime += time;
	Unlock();
#endif

#endif
}

// Profiling information
u32	FutureThreadPool::TotalJobsExecuted()
{
	return m_totalJobs;
}
f32	FutureThreadPool::AverageWaitTime()
{
#if FUTURE_PROFILE_THREAD_POOL
	return m_waitTime / (f32)m_totalJobs;
#endif
}
f32	FutureThreadPool::TimeOnMainThread()
{
#if FUTURE_PROFILE_THREAD_POOL
	return m_threadTime;
#endif
}
f32	FutureThreadPool::TimeSpentExecutingJobs()
{
#if FUTURE_PROFILE_THREAD_POOL
	return m_jobTime;
#endif
}

FutureThreadJob *	FutureThreadPool::GetNextJob()
{
#if FUTURE_PROFILE_THREAD_POOL
	f32 startTime = FutureTimer::CurrentTime();
#endif
	Lock();
	FutureThreadJob * job = m_jobs;
	if(job)
	{
		job->Lock();
#if FUTURE_PROFILE_THREAD_POOL
		job->m_timeStarted = startTime;
		m_waitTime += job->m_timeAdded - job->m_timeStarted;
#endif
		job->m_state = FutureThreadJob::JobState_Executing;
		m_jobs = m_jobs->m_next;
	}
#if FUTURE_PROFILE_THREAD_POOL
	f32 time = FutureTimer::TimeSince(startTime);
	m_threadTime += time;
#endif
	Unlock();
	return job;
}

void FutureThreadPool::JobFinished(FutureThreadJob * job)
{
#if FUTURE_PROFILE_THREAD_POOL
	f32 startTime = FutureTimer::CurrentTime();
#endif
	Lock();
	if(job)
	{
		job->Lock();
#if FUTURE_PROFILE_THREAD_POOL
		job->m_timeCompleted = startTime;
		m_jobTime += job->m_timeStarted - job->m_timeCompleted;
#endif
		job->m_state = FutureThreadJob::JobState_Finished;
		if(job->m_autoDelete)
		{
			delete job;
		}
		else
		{
			job->Unlock();
		}
	}
#if FUTURE_PROFILE_THREAD_POOL
	f32 time = FutureTimer::TimeSince(startTime);
	m_threadTime += time;
#endif
	Unlock();
}
thread.cpp/     1371847691  1006  513   100000  2311      `
/*!
*	Copyright 2013 by Lucas Stufflebeam mailto:info@indiegameadventures.com
*
*	Thank you for taking a look at my code. If you like it, please click
*	the donation button at the bottom of the sidebar on my blog. Thanks!
*
*	Licensed under the Apache License, Version 2.0 (the "License");
*	you may not use this file except in compliance with the License.
*	You may obtain a copy of the License at
*
*		http://www.apache.org/licenses/LICENSE-2.0
*
*	Unless required by applicable law or agreed to in writing, software
*	distributed under the License is distributed on an "AS IS" BASIS,
*	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*	See the License for the specific language governing permissions and
*	limitations under the License.
*
*/

/*
*	Implementation of IFutureThread
*
*/

#include <future/core/debug/debug.h>
#include <future/core/memory/memory.h>
#include <future/core/thread/thread/thread.h>

FutureResult IFutureThread::Join(f32 secondsTimeOut)
{
	return Join((u32)(secondsTimeOut / 1000.f));
}
void IFutureThread::Wait(f32 seconds)
{
	return Wait((u32)(seconds / 1000.f));
}
bool IFutureThread::IsStarted()
{
	return m_started;
}
bool IFutureThread::IsRunning()
{
	return m_started && !m_finished;
}
bool IFutureThread::IsFinished()
{
	return m_finished;
}

void IFutureThread::OnFinished()
{
	m_finished = true;
	if(m_onFinished)
	{
		m_onFinished(m_data);
	}
}

void IFutureThread::OnRunThread()
{
	m_started = true;
	if(m_function)
	{
		m_function(m_data);
	}
}

IFutureThread::IFutureThread()
	: m_data(NULL),
	  m_finished(false),
	  m_id(-1),
	  m_started(false),
	  m_priority(0),
	  m_function(NULL),
	  m_onFinished(NULL)
{}

#if FUTURE_ENABLE_MULTITHREADED
#	if FUTURE_PLATFORM_WINDOWS
#		include <future/core/thread/thread/win_thread.h>
#	elif defined(FUTURE_USES_PTHREAD)
#		include <future/core/thread/thread/posix_thread.h>
#	else
#		include <future/core/thread/thread/null_thread.h>
#	endif
#else
#	include <future/core/thread/thread/null_thread.h>
#endif
IFutureThread *	FutureCreateThread()
{
	return (IFutureThread*)(new FutureThread());
}
void FutureDestroyThread(IFutureThread * thread)
{
	if(thread)
	{
		thread->Join();
		delete thread;
	}
}

/138            1371868194  1006  513   100000  3446      `
/*!
*	Copyright 2013 by Lucas Stufflebeam mailto:info@indiegameadventures.com
*
*	Thank you for taking a look at my code. If you like it, please click
*	the donation button at the bottom of the sidebar on my blog. Thanks!
*
*	Licensed under the Apache License, Version 2.0 (the "License");
*	you may not use this file except in compliance with the License.
*	You may obtain a copy of the License at
*
*		http://www.apache.org/licenses/LICENSE-2.0
*
*	Unless required by applicable law or agreed to in writing, software
*	distributed under the License is distributed on an "AS IS" BASIS,
*	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*	See the License for the specific language governing permissions and
*	limitations under the License.
*
*/

/*
*	Implementation of FutureThread using posix threads
*
*/

#include <future/core/type/type.h>

#ifdef FUTURE_USES_PTHREAD

#include <future/core/thread/thread/posix_thread.h>
#include <future/core/utils/timer/timer.h>
#include <unistd.h>

void * FutureThread::RunThreadInternal(void * param)
{
	((FutureThread*)param)->OnRunThread();
	((FutureThread*)param)->OnFinished();
	return NULL;
}

FutureThread::FutureThread()
	: IFutureThread(),
	  m_thread(0)
{}

FutureThread::~FutureThread()
{
	if(IsRunning())
	{
		pthread_kill(m_thread);
	}
}

FutureResult FutureThread::Start(ThreadFunction function, void * data, FinishedCallbackFunction onFinished)
{
	// Make sure we aren't already started
	FUTURE_ASSERT(!m_started || m_finished);

	Lock();

	m_finished = false;
	m_onFinished = onFinished;
	m_function = function;
	m_data = data;

	pthread_attr_t attr;
	pthread_attr_init(&attr);
	__sched_param priority;
	priority.sched_priority = m_priority;
	pthread_attr_setschedparam(&attr, &priority);

	u32 result = pthread_create(&m_thread, &attr, &FutureThread::RunThreadInternal, (void *)this);
	m_id = (u64)m_thread;
	m_started = true;
	Unlock();

    switch (errno) 
	{
    case EINVAL:
		m_started = false;
		return FR_INVALID_ARG;
    case EAGAIN:
    case EPERM:
    default:
		m_started = false;
		return FR_ERROR;
    }

	return FR_OK;
}

void FutureThread::Join()
{
	FUTURE_ASSERT(m_thread);
	pthread_join(m_thread);
}

FutureResult FutureThread::Join(u32 milliTimeOut)
{
	FUTURE_ASSERT(m_thread);
	f32 timeToWait = (f32)milliTimeOut * 1000.f;
	f32 curTime = FutureTimer::CurrentTime();
	
	while(!m_finished && (milliTimeOut <= 0 || FutureTimer::TimeSince(curTime) < timeToWait))
	{
		sleep(5);
	}
	if(!m_finished)
	{
		return FR_TIMEOUT;
	}
	return FR_OK;
}

void FutureThread::Wait(u32 millis)
{
	sleep(millis);
}

void FutureThread::Kill()
{
	FUTURE_ASSERT(m_thread);
	pthread_kill(m_thread, 0);
}

u64 FutureThread::ThreadId()
{
	return m_id;
}
void* FutureThread::GetHandle()
{
	return (void*)&m_thread;
}

IFutureThread::FutureThreadPriority FutureThread::GetPriority()
{
	return (IFutureThread::FutureThreadPriority)m_priority;
}
void FutureThread::SetPriority(FutureThreadPriority priority)
{
	m_priority = priority;
	if(m_thread)
	{
		__sched_param priority;
		priority.sched_priority = m_priority;
		u32 policy;
		pthread_attr_getschedpolicy(&m_thread, &policy);
		pthread_setschedparam(&m_thread, policy, &priority);
	}
}

u64 IFutureThread::CurrentThreadId()
{
	return (u64)pthread_self();
}

#endif/156            1371868319  1006  513   100000  2192      `
/*!
*	Copyright 2013 by Lucas Stufflebeam mailto:info@indiegameadventures.com
*
*	Thank you for taking a look at my code. If you like it, please click
*	the donation button at the bottom of the sidebar on my blog. Thanks!
*
*	Licensed under the Apache License, Version 2.0 (the "License");
*	you may not use this file except in compliance with the License.
*	You may obtain a copy of the License at
*
*		http://www.apache.org/licenses/LICENSE-2.0
*
*	Unless required by applicable law or agreed to in writing, software
*	distributed under the License is distributed on an "AS IS" BASIS,
*	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*	See the License for the specific language governing permissions and
*	limitations under the License.
*
*/

/*
*	Implementation of FutureWorkerThread
*
*/

#include <future/core/thread/thread/workerthread.h>
#include <future/core/thread/pool/job.h>
#include <future/core/thread/pool/threadpool.h>
#include <future/core/utils/timer/timer.h>

FutureWorkerThread::FutureWorkerThread()
	: m_idle(false),
	  m_next(NULL)
{}
FutureWorkerThread::~FutureWorkerThread()
{
}

FutureResult FutureWorkerThread::WaitForJob(u32 milliTimeOut)
{
	if(m_idle)
	{
		return FR_OK;
	}
	f32 timeToWait = (f32)milliTimeOut * 1000.f;
	f32 curTime = FutureTimer::CurrentTime();
	
	while(!m_idle && (timeToWait <= 0 || FutureTimer::TimeSince(curTime) < timeToWait))
	{
		Sleep(5);
	}
	if(!m_idle)
	{
		return FR_TIMEOUT;
	}
	return FR_OK;
}

void FutureWorkerThread::OnFinished()
{
	m_finished = true;
	if(m_onFinished)
	{
		m_onFinished(m_data);
	}
}

void FutureWorkerThread::Release()
{
	m_running = false;
	Join();
}

void FutureWorkerThread::OnRunThread()
{
	m_started = true;
	m_idle = false;
	m_running = true;
#if FUTURE_ENABLE_MULTITHREADED
	while(m_running)
	{
#endif
		FutureThreadJob * job = FutureThreadPool::GetInstance()->GetNextJob();
		
		if(job)
		{
			m_idle = false;
			job->Execute(this);
			FutureThreadPool::GetInstance()->JobFinished(job);
		}
		else
		{
			m_idle = true;
			Sleep(5);
		}
#if FUTURE_ENABLE_MULTITHREADED
	}
#endif
}